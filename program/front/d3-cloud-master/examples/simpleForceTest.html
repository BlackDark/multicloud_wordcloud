<!DOCTYPE html>
<html>
<head lang="en">
	<meta charset="UTF-8">
	<title></title>
	<style>

		.link {
			stroke: #000;
			stroke-width: 1.5px;
		}

		.node {
			cursor: move;
			fill: #ccc;
			stroke: #000;
			stroke-width: 1.5px;
		}

		.node.fixed {
			fill: #f00;
		}

		.noselect {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

		text {
		}

		#width-test {
			position: absolute;
			float: left;
			white-space: nowrap;
			visibility: hidden;
		}

	</style>
</head>
<body>
<script src="d3/d3.js"></script>
<script>(function () {

	var drawLinks = false;
	var showOriginalPos = true;
	var fill = d3.scale.category20();

	var width = 960,
			height = 500;

	function testStrength(link, index) {
		if (link.strength) {
			return link.strength;
		}

		return 0.1;
	}

	var force = d3.layout.force()
			.size([width, height])
			// Gravity removed for positioning only with links
			//.gravity(0)
			.charge(-50)
			.linkDistance(20)
			.linkStrength(testStrength)
			.on("tick", tick);

	var drag = force.drag()
			.on("dragstart", dragstart);

	var svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height);

	var link = svg.selectAll(".link"),
			node = svg.selectAll(".node");

	var originalPosLink;

	var nodes = getObjects(4);

	var links = createLinks(nodes, 4);

	force.nodes(nodes)
				.links(links)
				.on("end", drawOriginalPositionLink)
				.start();

	if (drawLinks) {
		link = link.data(links)
				.enter().append("line")
				.attr("class", "link");
	}

		node = node.data(nodes)
				.enter().append("g");

	node.append("title")
			.text(function(d) {
				return "End1: " + d.end1
						+ " End2: " + d.end2
						+ " End3: " + d.end3
						+ " End4: " + d.end4
			});

		node.append("text")
				.style("font-family", "Impact")
				.style("fill", function(d, i) { return fill(i); })
				.attr("text-anchor", "middle")
				.style("font-size", function(d) {
					var size = Math.floor(Math.random() * 15 + 12);
					return size + "px"; })
				.text(function(d) {
					return d.text;
				})
				.on("dblclick", dblclick)
				.call(drag);

	function tick() {
		if (drawLinks) {
			link.attr("x1", function (d) {
				return d.source.x;
			})
					.attr("y1", function (d) {
						return d.source.y;
					})
					.attr("x2", function (d) {
						return d.target.x;
					})
					.attr("y2", function (d) {
						return d.target.y;
					});
		}

		node.attr("transform", function(d) {
			return "translate(" + [d.x, d.y] + ")";
		});
		node.each(collide(.5));
	}

	// Resolves collisions between d and all other circles.
	function collide(alpha) {
		var quadtree = d3.geom.quadtree(nodes);

		return function (d) {

			for(var i = 4; i < nodes.length; i++) {
				if(nodes[i] === d) {
					continue;
				}

				if ( (d.x + d.textWidth / 2) > (nodes[i].x - nodes[i].textWidth / 2) &&
						(d.x - d.textWidth / 2) < (nodes[i].x + nodes[i].textWidth / 2)) {
					var xDif = (d.x + d.textWidth / 2) - (nodes[i].x - nodes[i].textWidth / 2) * alpha;
					//d.x -= xDif / 2;
					//nodes[i].x += xDif;
					d.x -= 1;
					nodes[i].x += 2;
				}
			}

			return;


					var nx1 = d.x - d.textWidth,
					nx2 = d.x + d.textWidth,
					ny1 = d.y - d.size,
					ny2 = d.y + d.size;
			quadtree.visit(function (quad, x1, y1, x2, y2) {

				var col = true;
				if (quad.point && (quad.point !== d)) {
					if ( (d.x + d.textWidth / 2) > (quad.point.x - quad.point.textWidth / 2) &&
							(d.x - d.textWidth / 2) < (quad.point.x + quad.point.textWidth / 2)) {
						var xDif = (d.x + d.textWidth / 2) - (quad.point.x - quad.point.textWidth / 2) * alpha;
						console.log(d.x + " " + quad.point.x + " " + xDif);
						//d.x -= xDif / 2;
						//quad.point.x += xDif;
						d.x -= 1;
						quad.point.x += 2;
						console.log("TEST");
						col = false;
					}

					if ( (d.x - d.textWidth / 2) > (quad.point.x + quad.point.textWidth / 2) &&
							(d.x + d.textWidth / 2) < (quad.point.x - quad.point.textWidth / 2)) {
						var xDif = (d.x + d.textWidth / 2) - (quad.point.x - quad.point.textWidth / 2) * alpha;
						console.log(d.x + " " + quad.point.x + " " + xDif);
						//d.x -= xDif / 2;
						//quad.point.x += xDif;
						d.x += 1;
						quad.point.x -= 2;
						col = false;
					}

					/*
					var x = d.x - quad.point.x,
							y = d.y - quad.point.y,
							l = Math.sqrt(x * x + y * y),
							r = d.x;
					if (l < r) {
						l = (l - r) / l * alpha;
						d.x -= x *= l;
						d.y -= y *= l;
						quad.point.x += x;
						quad.point.y += y;
					}
					*/
				}
				return col;
			});
		};
	}

	function drawOriginalPositionLink() {
		if(!showOriginalPos) {
			  return;
		}

		originalPosLink = svg.append("g");

		for(var i = 4; i < nodes.length; i++) {
			var positionX = nodes[0].x * nodes[i].end1 +
					nodes[1].x * nodes[i].end2 +
					nodes[2].x * nodes[i].end3 +
					nodes[3].x * nodes[i].end4;

			var positionY = nodes[0].y * nodes[i].end1 +
					nodes[1].y * nodes[i].end2 +
					nodes[2].y * nodes[i].end3 +
					nodes[3].y * nodes[i].end4;

			originalPosLink.append("line")
					.attr("class", "link")
					.attr("x1", function (d) {
						return nodes[i].x;
					})
					.attr("y1", function (d) {
						return nodes[i].y;
					})
					.attr("x2", function (d) {
						return positionX;
					})
					.attr("y2", function (d) {
						return positionY;
					});
		}
	}

	function dblclick(d) {
		d3.select(this).classed("fixed", d.fixed = false);
	}

	function dragstart(d) {
		return;
		d3.select(this).classed("fixed", d.fixed = true);
	}


	function getObjects(numberOfDocuments) {
		var text = "What the cynics fail to understand is that the ground has shifted beneath them - that the stale political arguments that have consumed us for so long no longer apply. The question we ask today is not whether our government is too big or too small, but whether it works - whether it helps families find jobs at a decent wage, care they can afford, a retirement that is dignified. Where the answer is yes, we intend to move forward. Where the answer is no, programs will end. And those of us who manage the public's dollars will be held to account - to spend wisely, reform bad habits, and do our business in the light of day - because only then can we restore the vital trust between a people and their government.	Nor is the question before us whether the market is a force for good or ill. Its power to generate wealth and expand freedom is unmatched, but this crisis has reminded us that without a watchful eye, the market can spin out of control - and that a nation cannot prosper long when it favors only the prosperous. The success of our economy has always depended not just on the size of our Gross Domestic Product, but on the reach of our prosperity; on the ability to extend opportunity to every willing heart - not out of charity, but because it is the surest route to our common good.";

		var tokenArray = text.split(" ");

		var te = [];

		te = te.concat(getEndpoints(4));
		te = te.concat(getTextObjects(tokenArray, 4));

		return te;
	}

	function getEndpoints(numDocs) {
		return [
			{
				text: "End1",
				x: 5,
				y: 5,
				fixed: true,
				id: 0
			},
			{
				text: "End2",
				x: width - 5,
				y: 5,
				fixed: true,
				id: 1
			},
			{
				text: "End3",
				x: 5,
				y: height - 5,
				fixed: true,
				id: 2
			},
			{
				text: "End4",
				x: width - 5,
				y: height - 5,
				fixed: true,
				id: 3
			}
		];
	}

	function getTextObjects(tokenArray, numDocs){
		var objects = [];
		var index = 4;



		tokenArray.forEach(function(entry) {
			var distr = getRandomDistribution(4);

			objects.push({
				text: entry,
				textWidth: widthText(entry),
				size: 12,
				end1: distr[0],
				end2: distr[1],
				end3: distr[2],
				end4: distr[3],
				id: +index
			});

			index++;
		});

		return objects;
	}

	function getRandomDistribution(numNumbers) {
		var randomNumers = [];

		for(var i = 0; i < numNumbers - 1; i++) {
			randomNumers.push(Math.random());
		}

		randomNumers.sort(function(a, b){return a-b});

		var recalc = [];

		for(var j = 0; j < numNumbers; j++) {
			if (j === 0) {
				recalc.push(randomNumers[j] - 0);
				continue;
			}

			if (j === numNumbers - 1) {
				recalc.push(1 - randomNumers[j - 1]);
				continue;
			}

			recalc.push(randomNumers[j] - randomNumers[j - 1]);

		}
		return shuffle(recalc);
	}

	function shuffle(o){
		for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
		return o;
	}

	function createLinks(nodes, number) {
		var newLinks = [];

		for(var i = number; i < nodes.length; i++) {
			var currentNode = nodes[i];

			newLinks.push({
				source: currentNode.id,
				target: 0,
				strength: currentNode.end1
			});

			newLinks.push({
				source: currentNode.id,
				target: 1,
				strength: currentNode.end2
			});

			newLinks.push({
				source: currentNode.id,
				target: 2,
				strength: currentNode.end3
			});

			newLinks.push({
				source: currentNode.id,
				target: 3,
				strength: currentNode.end4
			});
		}

		return newLinks;
	}

	function widthText(text, textStyle) {
		// Set a default value
		if (!textStyle) {
			textStyle = "text";
		}

		var d = d3.select("body")
						.append("div")
						.attr("class", textStyle)
						.attr("id", "width-test") // tag this element to identify it
						.text(text),
				w = document.getElementById("width-test").offsetWidth;
		d.remove();
		console.log(w);
		return w;
	}

})();</script>
