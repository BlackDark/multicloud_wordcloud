<!DOCTYPE html>
<html>
<head lang="en">
	<meta charset="UTF-8">
	<title></title>
	<style>

		.link {
			stroke: #000;
			stroke-width: 1.5px;
		}

		.node {
			cursor: move;
			fill: #ccc;
			stroke: #000;
			stroke-width: 1.5px;
		}

		.node.fixed {
			fill: #f00;
		}

		.noselect {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

		rect.overlap {
			fill: red;
		}

		text {
		}

		#width-test {
			position: absolute;
			float: left;
			white-space: nowrap;
			visibility: hidden;
		}

	</style>
</head>
<body>
<script src="d3/d3.js"></script>
<script src="cola/cola.v3.min.js"></script>
<script>(function () {

	var drawWords = false;
	var drawLinks = false;
	var showOriginalPos = true;
	var reduceLinkStrength = false;
	var variableCharge = true;
	var collisionRemovalTimes = 200;

	var fill = d3.scale.category20();

	var width = 960,
			height = 500;

	function testStrength(link, index) {
		if (link.strength) {
			if(reduceLinkStrength) {
				return link.strength - 0.05 < 0 ? 0 : link.strength - 0.05;
			} else {
				return link.strength;
			}
		}

		return 0.1;
	}

	var force = d3.layout.force()
			.size([width, height])
			// Gravity removed for positioning only with links
			//.gravity(0)
			.charge(variableCharge ? chargeTest : -60)
			.linkDistance(20)
			.linkStrength(testStrength)
			.on("tick", tick);

	function chargeTest(theNode) {
		if(theNode.width) {
			return theNode.width * (-4);
		}

		return 0;
	}

	var drag = force.drag()
			.on("dragstart", dragstart);

	var svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height);

	var link = svg.selectAll(".link"),
			node = svg.selectAll(".node");

	var originalPosLink;

	var nodes = getObjects(4);

	var links = createLinks(nodes, 4);

	force.nodes(nodes)
				.links(links)
				.on("end", onEnd)
				.start();

	if (drawLinks) {
		link = link.data(links)
				.enter().append("line")
				.attr("class", "link");
	}

		node = node.data(nodes)
				.enter().append("g");

	node.append("title")
			.text(function(d) {
				return "End1: " + d.end1
						+ " End2: " + d.end2
						+ " End3: " + d.end3
						+ " End4: " + d.end4
			});


	node.each(function(current) {
		if (drawWords) {
			d3.select(this).append("text")
					.style("font-family", "Impact")
					.style("fill", function(d, i) { return fill(i); })
					.attr("text-anchor", "middle")
					.style("font-size", function(d) {
						var size = Math.floor(Math.random() * 15 + 12);
						return size + "px"; })
					.text(function(d) {
						return d.text;
					})
					.on("dblclick", dblclick)
					.call(drag);
		} else {
			current.rectContainer = d3.select(this).append("rect")
					.attr("width", function (d) {
						return d.width
					})
					.attr("height", function (d) {
						return d.size
					});
		}
	});

	function tick() {
		if (drawLinks) {
			link.attr("x1", function (d) {
				return d.source.x;
			})
					.attr("y1", function (d) {
						return d.source.y;
					})
					.attr("x2", function (d) {
						return d.target.x;
					})
					.attr("y2", function (d) {
						return d.target.y;
					});
		}

		var q = d3.geom.quadtree(nodes),
				i = 3,
				n = nodes.length;

		while (++i < n) {
			q.visit(collide(nodes[i]));
		}

		node.attr("transform", function(d) {
			return "translate(" + [d.x, d.y] + ")";
		});
	}

	var bounds = {
		x0: 0,
		y0: 0,
		x1: width,
		y2: height
	};

	function isInBounds(node, boundingArea) {
		return node.x >= boundingArea.x0 && node.y >= boundingArea.y0;
	}

	function hasCollision(node, area) {
		return node.x < area.x + area.width &&
				node.x + node.width > area.x &&
				node.y < area.y + area.height &&
				node.height + node.y > area.y;
	}

	function moveToTopLeft() {
		var uncheckedNodes = boundsSortedNodes(nodes.slice(4, nodes.length));
		var checkedNodes = [];
		var restKnoten = [].concat(uncheckedNodes);
		//uncheckedNodes = uncheckedNodes.slice(0, 1);

		uncheckedNodes.forEach(function(currentNode) {
			// Remove this node from other nodes
			restKnoten = restKnoten.splice(1, restKnoten.length);

			var movable = isInBounds(currentNode, bounds);

			while(movable) {
				var failMove = 0;

				currentNode.x = currentNode.x - 2;

				if(!isInBounds(currentNode, bounds) || testOverlap(currentNode, checkedNodes)) {
					currentNode.x = currentNode.x + 2;
					failMove++;
				}

				currentNode.y = currentNode.y - 2;

				if(!isInBounds(currentNode, bounds) || testOverlap(currentNode, checkedNodes)) {
					currentNode.y = currentNode.y + 2;
					failMove++;
				}

				if (failMove === 2) {
					movable = false;
				}
			}

			checkedNodes.push(currentNode);
			node.select(function(d){if(d.id === currentNode.id) { return this}}).transition()
					.duration(750)
					.delay(200 * checkedNodes.length)
					.attr("transform", function(d) {
						return "translate(" + [d.x, d.y] + ")";
					})
		});

		// Moving the nodes flawlessy
		/*
		node.transition()
				.duration(750)
				.attr("transform", function(d) {
			return "translate(" + [d.x, d.y] + ")";
		});
		*/
	}

	function boundsSortedNodes(nodesToSort) {
		var unsortedArray = [].concat(nodesToSort);

		// Sorting x,y pref of x => a.x - b.x || a.y - b.y

		unsortedArray.sort(function(a, b) {
			return Math.sqrt(Math.pow(a.x, 2) + Math.pow(a.y, 2)) - Math.sqrt(Math.pow(b.x, 2) + Math.pow(b.y, 2));
		});

		return unsortedArray;
	}

	function printDistance(array){
		var positions = [];

		array.forEach(function(element) {
			positions.push("[" + Math.round(Math.sqrt(Math.pow(element.x, 2) + Math.pow(element.y, 2))) + "]");
		});

		console.log(positions.toString());
	}

	function printXY(array) {
		var positions = [];
		array.forEach(function(element) {
			positions.push("[" + element.x + "," + element.y + "]");
		});

		console.log(positions.toString());
	}

	function testOverlap(testNode, testArrayNodes) {
		for(var i = 0; i < testArrayNodes.length; i++) {
			if (testNode === testArrayNodes[i]) {
				continue;
			}

			if(hasCollision(testNode, testArrayNodes[i])) {
				console.log(testNode.x + " " + testNode.y + " || " + testArrayNodes[i].x + " " + testArrayNodes[i].y);
				return true;
			}
		}

		return false;
	}

	function hasOverlap(node, nodes) {
		var overlap = false;

		nodes.forEach(function(checkNode){
			if (checkNode && (checkNode !== node)) {

				var xSpacing = (checkNode.width + node.width) / 2,
						ySpacing = (checkNode.height + node.height) / 2,
						absX = Math.abs(node.x - checkNode.x),
						absY = Math.abs(node.y - checkNode.y);

				if (absX < xSpacing && absY < ySpacing) {
					overlap = true;
				}
			}
		});

		return overlap;
	}

	// Collision not working that good
	function collide(node) {

		return function(quad, x1, y1, x2, y2) {
			var updated = false;
			if (quad.point && (quad.point !== node)) {

				var x = node.x - quad.point.x,
						y = node.y - quad.point.y,
						xSpacing = (quad.point.width + node.width) / 2,
						ySpacing = (quad.point.height + node.height) / 2,
						absX = Math.abs(x),
						absY = Math.abs(y),
						l,
						lx,
						ly;

				if (absX < xSpacing && absY < ySpacing) {
					l = Math.sqrt(x * x + y * y);

					lx = (absX - xSpacing) / l;
					ly = (absY - ySpacing) / l;

					// the one that's barely within the bounds probably triggered the collision
					if (Math.abs(lx) > Math.abs(ly)) {
						lx = 0;
					} else {
						ly = 0;
					}

					node.x -= x *= lx;
					node.y -= y *= ly;
					quad.point.x += x;
					quad.point.y += y;

					updated = true;
				}
			}
			return updated;
		};
	}

	function tryOverlapRemoval() {
		for(var i = 0; i < collisionRemovalTimes; i++) {
			var q = d3.geom.quadtree(nodes),
					j = 3,
					n = nodes.length;

			while (++j < n) {
				q.visit(collide(nodes[j]));
			}
		}
	}

	function onEnd(){
		//tryOverlapRemoval();
		moveToTopLeft();
		drawOriginalPositionLink();
		markOverlapping();
	}

	function markOverlapping() {
		for (var i = 4; i < nodes.length; i++) {
			if(testOverlap(nodes[i], nodes)) {
				nodes[i].rectContainer.classed("overlap", true);
			}
		}
	}

	function drawOriginalPositionLink() {
		if(!showOriginalPos) {
			  return;
		}

		originalPosLink = svg.append("g");

		for(var i = 4; i < nodes.length; i++) {
			var positionX = nodes[0].x * nodes[i].end1 +
					nodes[1].x * nodes[i].end2 +
					nodes[2].x * nodes[i].end3 +
					nodes[3].x * nodes[i].end4;

			var positionY = nodes[0].y * nodes[i].end1 +
					nodes[1].y * nodes[i].end2 +
					nodes[2].y * nodes[i].end3 +
					nodes[3].y * nodes[i].end4;

			originalPosLink.append("line")
					.attr("class", "link")
					.attr("x1", function (d) {
						return nodes[i].x;
					})
					.attr("y1", function (d) {
						return nodes[i].y;
					})
					.attr("x2", function (d) {
						return positionX;
					})
					.attr("y2", function (d) {
						return positionY;
					});
		}
	}

	function dblclick(d) {
		d3.select(this).classed("fixed", d.fixed = false);
	}

	function dragstart(d) {
		return;
		d3.select(this).classed("fixed", d.fixed = true);
	}


	function getObjects(numberOfDocuments) {
		var text = "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum. Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum. Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum. What the cynics fail to understand is that the ground has shifted beneath them - that the stale political arguments that have consumed us for so long no longer apply. The question we ask today is not whether our government is too big or too small, but whether it works - whether it helps families find jobs at a decent wage, care they can afford, a retirement that is dignified. Where the answer is yes, we intend to move forward. Where the answer is no, programs will end. And those of us who manage the public's dollars will be held to account - to spend wisely, reform bad habits, and do our business in the light of day - because only then can we restore the vital trust between a people and their government.	Nor is the question before us whether the market is a force for good or ill. Its power to generate wealth and expand freedom is unmatched, but this crisis has reminded us that without a watchful eye, the market can spin out of control - and that a nation cannot prosper long when it favors only the prosperous. The success of our economy has always depended not just on the size of our Gross Domestic Product, but on the reach of our prosperity; on the ability to extend opportunity to every willing heart - not out of charity, but because it is the surest route to our common good.";

		var text = "Kleiner Test Text um die Wörter zu verschieben in gewünschte Richtung";
		//var text = "Overlap Test";
		var tokenArray = text.split(" ");

		console.log(tokenArray.length + " words.");

		var te = [];

		te = te.concat(getEndpoints(4));
		te = te.concat(getTextObjects(tokenArray, 4));

		return te;
	}

	function getEndpoints(numDocs) {
		return [
			{
				text: "End1",
				x: 5,
				y: 5,
				fixed: true,
				id: 0
			},
			{
				text: "End2",
				x: width - 5,
				y: 5,
				fixed: true,
				id: 1
			},
			{
				text: "End3",
				x: 5,
				y: height - 5,
				fixed: true,
				id: 2
			},
			{
				text: "End4",
				x: width - 5,
				y: height - 5,
				fixed: true,
				id: 3
			}
		];
	}

	function getTextObjects(tokenArray, numDocs){
		var objects = [];
		var index = 4;



		tokenArray.forEach(function(entry) {
			var distr = getRandomDistribution(4);
			//var height = Math.floor(Math.random() * 30 + 12);
			var height = 12;
			objects.push({
				text: entry,
				size: height,
				width: widthText(entry),
				height: height,
				end1: distr[0],
				end2: distr[1],
				end3: distr[2],
				end4: distr[3],
				id: +index
			});

			index++;
		});

		return objects;
	}

	function getRandomDistribution(numNumbers) {
		var randomNumers = [];

		for(var i = 0; i < numNumbers - 1; i++) {
			randomNumers.push(Math.random());
		}

		randomNumers.sort(function(a, b){return a-b});

		var recalc = [];

		for(var j = 0; j < numNumbers; j++) {
			if (j === 0) {
				recalc.push(randomNumers[j] - 0);
				continue;
			}

			if (j === numNumbers - 1) {
				recalc.push(1 - randomNumers[j - 1]);
				continue;
			}

			recalc.push(randomNumers[j] - randomNumers[j - 1]);

		}
		return shuffle(recalc);
	}

	function shuffle(o){
		for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
		return o;
	}

	function createLinks(nodes, number) {
		var newLinks = [];

		for(var i = number; i < nodes.length; i++) {
			var currentNode = nodes[i];

			newLinks.push({
				source: currentNode.id,
				target: 0,
				strength: currentNode.end1
			});

			newLinks.push({
				source: currentNode.id,
				target: 1,
				strength: currentNode.end2
			});

			newLinks.push({
				source: currentNode.id,
				target: 2,
				strength: currentNode.end3
			});

			newLinks.push({
				source: currentNode.id,
				target: 3,
				strength: currentNode.end4
			});
		}

		return newLinks;
	}

	function widthText(text, textStyle) {
		// Set a default value
		if (!textStyle) {
			textStyle = "text";
		}

		var d = d3.select("body")
						.append("div")
						.attr("class", textStyle)
						.attr("id", "width-test") // tag this element to identify it
						.text(text),
				w = document.getElementById("width-test").offsetWidth;
		d.remove();
		return w;
	}

})();</script>
